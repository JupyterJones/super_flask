import moviepy.editor as mp
import numpy as np
import os
import glob
import subprocess
import logging
import shutil
import uuid
import random
from moviepy.video.VideoClip import ColorClip
from moviepy.editor import CompositeVideoClip, ImageClip, AudioFileClip, VideoFileClip

logging.basicConfig(level=logging.INFO)

def resize_if_needed(clip, target_size=(512, 768)):
    """Resizes the clip if it is not already the target size."""
    if clip.size != target_size:
        logging.info(f"Image size {clip.size} is not {target_size}, resizing...")
        return clip.resize(target_size)
    logging.info(f"Image is already the correct size: {clip.size}")
    return clip

def slide_apart_animation(foreground_path, background_path, output_path, duration=3, fps=24):
    logging.info(f"Loading images {foreground_path} and {background_path}...")

    # Load foreground and background images
    foreground = mp.ImageClip(foreground_path)
    background = mp.ImageClip(background_path)

    # Verify and resize if needed
    logging.info("Verifying and resizing images if necessary...")
    foreground = resize_if_needed(foreground)
    background = resize_if_needed(background)

    # Split the foreground into two halves
    logging.info("Splitting the foreground image into two halves.")
    left_half = foreground.crop(x1=0, y1=0, x2=256, y2=768)
    right_half = foreground.crop(x1=256, y1=0, x2=512, y2=768)

    # Define the sliding effect
    def make_frame(t):
        # Calculate how much the images have moved by time 't'
        slide_distance = min(256, int(256 * t / duration))

        # Create a blank frame (RGB format)
        frame = np.zeros((768, 512, 3), dtype=np.uint8)

        # Add background image to the frame
        frame[:, :, :] = background.get_frame(t)

        # Add the left sliding half
        if slide_distance < 256:
            left_part_width = 256 - slide_distance
            frame[:, :left_part_width] = left_half.get_frame(t)[:, slide_distance:256]

        # Add the right sliding half
        if slide_distance < 256:
            right_part_width = 256 + slide_distance
            frame[:, right_part_width:] = right_half.get_frame(t)[:, :256 - slide_distance]

        return frame

    # Create a video clip from the frames generated by make_frame
    logging.info(f"Creating the animation for {output_path}...")
    animation = mp.VideoClip(make_frame, duration=duration)

    # Set the fps and write the video file
    animation.write_videofile(output_path, fps=fps)

    logging.info("Animation complete.")

def get_image_list():
    image_directory = "static/novel_images/"
    # Get the list of images in the directory and sort them by date last modified
    image_list = sorted(glob.glob(os.path.join(image_directory, '*.png'))) + sorted(glob.glob(os.path.join(image_directory, '*.jpg')))
    image_list = sorted(image_list, key=os.path.getmtime)
    return image_list

def build_animation(output_directory="static/temp_exp"):
    # Ensure output directory exists
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Get the list of images
    image_list = get_image_list()

    # Create a list to hold the output video files
    output_files = []

    # Generate the animations
    for i in range(0, len(image_list)-1):
        # Create a unique output video filename
        output_animation = os.path.join(output_directory, 
            image_list[i].split("/")[-1].split(".")[0] + "_to_" + image_list[i+1].split("/")[-1].split(".")[0] + ".mp4")
        
        # Generate sliding animation between images
        slide_apart_animation(image_list[i], image_list[i+1], output_animation)
        
        # Add the output file to the list
        output_files.append(output_animation)

    # Concatenate all the generated videos
    final_output_video_path = concatenate_videos(output_files, output_directory)

    # Add border and title image to the concatenated video
    add_title_image(final_output_video_path)

def concatenate_videos(video_paths, output_directory):
    # Prepare for concatenation of all generated videos
    input_list_path = os.path.join(output_directory, "input_list.txt")
    with open(input_list_path, 'w') as input_list_file:
        for video_path in video_paths:
            input_list_file.write(f"file '{os.path.abspath(video_path)}'\n")

    # Concatenate videos using ffmpeg
    concatenated_video_path = os.path.join(output_directory, "Sliding_DoorsX.mp4")
    ffmpeg_command = f"ffmpeg -y -f concat -safe 0 -i {input_list_path} -c copy -y {concatenated_video_path}"
    subprocess.run(ffmpeg_command, shell=True, check=True)

    logging.info(f"Final concatenated video saved as {concatenated_video_path}")

    # Clean up temporary files
    for video_path in video_paths:
        os.remove(video_path)
    os.remove(input_list_path)

    logging.info("Temporary files cleaned up.")
    final_output_directory = "/home/jack/Desktop/HDD500/collections/vids/"
    os.makedirs(final_output_directory, exist_ok=True)
    final_output_video_path = os.path.join(final_output_directory, str(uuid.uuid4()) + ".mp4")
    shutil.copyfile(concatenated_video_path, final_output_video_path)
    return final_output_video_path

def add_title_image(video_path, hex_color="#A52A2A"):
    hex_color = random.choice(["#A52A2A", "#ad1f1f", "#16765c", "#7a4111", "#9b1050", "#8e215d", "#2656ca"])
    directory_path = "static/temp"
    if not os.path.exists(directory_path):
        os.makedirs(directory_path)
        logging.info(f"Directory '{directory_path}' created.")
    else:
        logging.info(f"Directory '{directory_path}' already exists.") 
    video_clip = VideoFileClip(video_path)
    width, height = video_clip.size
    get_duration = video_clip.duration
    logging.info(f"Video duration: {get_duration}, width: {width}, height: {height}")
    title_image_path = "static/assets/open_doors.png"
    padded_size = (width + 50, height + 50)
    x_position = (padded_size[0] - video_clip.size[0]) / 2
    y_position = (padded_size[1] - video_clip.size[1]) / 2
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)
    rgb_tuple = (r, g, b)
    blue_background = ColorClip(padded_size, color=rgb_tuple)
    padded_video_clip = CompositeVideoClip([blue_background, video_clip.set_position((x_position, y_position))])
    padded_video_clip = padded_video_clip.set_duration(video_clip.duration)
    title_image = ImageClip(title_image_path).set_duration(video_clip.duration).set_position((0, -5)).resize(padded_video_clip.size)
    composite_clip = CompositeVideoClip([padded_video_clip, title_image]).set_duration(video_clip.duration)
    mp3_files = glob.glob("/mnt/HDD500/collections/music_long/*.mp3")
    random.shuffle(mp3_files)
    mp_music = random.choice(mp3_files)
    music_clip = AudioFileClip(mp_music)
    music_duration = music_clip.duration
    start_time = random.uniform(20, 40)
    if start_time + video_clip.duration > music_duration:
        start_time = max(0, music_duration - video_clip.duration)
    music_clip = music_clip.subclip(start_time, start_time + video_clip.duration).set_duration(video_clip.duration)
    fade_duration = 1.0
    music_clip = music_clip.audio_fadein(fade_duration).audio_fadeout(fade_duration)
    composite_clip = composite_clip.set_audio(music_clip)
    uid = uuid.uuid4().hex
    output_path = f'static/temp_exp/OPEN_doorsX.mp4'
    composite_clip.write_videofile(output_path)
    mp4_file = f"/mnt/HDD500/collections/vids/AI_Creates_a_Flipbook_of_Processed_AI_Generated_Images_ID{uid}.mp4"
    shutil.copyfile(output_path, mp4_file)
    logging.info(mp4_file)
    return output_path

if __name__ == "__main__":
    build_animation()
#     # Paths to the foreground and background images and output MP4